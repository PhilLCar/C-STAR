;; include (parsing/bnf/expressions.bnf)
;; include (parsing/bnf/types.bnf)
#;; include (parsing/bnf/oop.bnf)
#;; include (parsing/bnf/operator.bnf)

<program> ::= { ( <statement> | <address> /*| <class-decl> | <operator-assoc>*/ ) }

<statement> ::= <block> | <special-blocks>

<block>       ::= <line> | "{" { <statement> } "}"
<line>        ::= [ <expression> | <declaration> | <control> ] ";" | ( <expression> | <declaration> | <control> ) <raw: newline>
<declaration> ::= <type> ( <expression> - <call> | <prototype> )
<prototype>   ::= <raw:variable> "(" [ <type> <raw: variable> { "," <type> <raw: variable> } ] ")"
<control>     ::= "goto" <raw: variable> | "break" [ <expression> ] | "continue" [ <expression> ] | "finish" [ <expression> ]

<special-blocks> ::= <if-block> | <if-else-block> | <while-block> | <for-block> | <foreach-block> | <switch-block> | <metafor-block>
<do-block>       ::= "do" <statement>
<if-else-block>  ::= "if" <log-or> <statement> - <if-block> "else" <statement>
<if-block>       ::= "if" <log-or> <statement>
<while-block>    ::= [ <do-block> ] "while" <log-or> <statement>
<for-block>      ::= [ <do-block> ] "for" "(" [ <expression> | <declaration> ] ";" [ <expression> ] ";" [ <expression> ] ")" <statement>
<foreach-block>  ::= [ <do-block> ] "for" "each" "(" [ <expression> ] ( "in" | "of" ) <expression> ")" <statement>
<switch-block>   ::= "switch" <log-or> "{" { <switch-label> ":" { <statement> } } "}"

# var[10, 10, 10] a;
#
# metafor (var x in a) {
# 	// normal access, if you know a's structure
# 	a[x[0], x[1], x[2]] = wtv;
# 	// meta access, if a's structure is unknown
# 	a[meta x] = wtv;
# }
<metafor-block> ::= [ <do-block> ] "meta" "for" "(" [ <declaration> ] "in" <expression> ")" <block>

<address>      ::= <raw: variable> ":"
<switch-label> ::= ( "case" <expression> | "default" ) ":"